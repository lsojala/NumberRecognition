import tensorflow as tf
import numpy as np

from random import randint

from modules.LoadMNIST import load_mnist


class DigitAI:
    def __init__(self):
        self.data_path = "Data/"
        self.AI_path = "Brains/"
        self.AI_name = "MNIST_Digit_Recognizer"
        self.learn_rate = 1e-4


        self.primer = {
            "certain": ["I'm sure that is ","I know! That's ", "Clearly, that is "],
            "confident": ["I think that is ", "I believe that's ","I would say that's "],
            "unsure": ["That could be ", "That's maybe ", "I'm guessing that's "],
            "clueless": ["I have no clue..","That could be anything..","Nope, I got nothing.."]
            }
    
        self.digit = {
            0: "zero",
            1: "one",
            2: "two",
            3: "three",
            4: "four",
            5: "five",
            6: "six",
            7: "seven",
            8: "eight",
            9: "nine"}


        try:
            self.core = tf.keras.models.load_model(self.AI_path+self.AI_name)
        except IOError:
            self.core = self._define_core_AI()
            self._train_AI()
            self.core.save(self.AI_path+self.AI_name)

        self.core.summary()


    def _load_data(self):
        """
        Retries and stores data from the MNIST-files
        """
        self.train_x = load_mnist("train images",self.data_path)
        self.train_y = load_mnist("train labels",self.data_path)
    
        self.test_x = load_mnist("test images",self.data_path)    
        self.test_y = load_mnist("test labels",self.data_path)



    def _define_core_AI(self):
        """
        Core funtionality of MNIST digit recognition AI
        Takes in array of 28 x 28 cells (MNIST data size)
        Returns identification in one hot encoded vector
        """
        input = tf.keras.layers.Input(shape=(28,28,1))

        #conv1 = tf.keras.layers.Conv2D(filters=64,kernel_size = (9,9),activation="relu",kernel_initializer="he_normal")(inputs) #padding="same",
        #pool1 = tf.keras.layers.MaxPooling2D(pool_size=(2,2))(conv1)
        #conv2 = tf.keras.layers.Conv2D(filters=32,kernel_size = (5,5),activation="relu",kernel_initializer="he_normal")(pool1)
        #pool2 = tf.keras.layers.MaxPooling2D(pool_size=(2,2))(conv2)
        flat = tf.keras.layers.Flatten(input_shape=(28, 28, 1))(input) #(pool2)
        dens1 = tf.keras.layers.Dense(units=784,activation ="relu")(flat)
        drop1 = tf.keras.layers.Dropout(0.2, input_shape=(784,))(dens1)
        digits = tf.keras.layers.Dense(units=10,activation ="linear")(drop1)

        # loss_fn = tf.keras.losses.CategoricalCrossentropy()


        model = tf.keras.models.Model(inputs=input,outputs=digits,name="CoreCNN")
        model.compile(
            optimizer = tf.keras.optimizers.Adam(learning_rate=self.learn_rate),
            loss = "mse",         #for loss = "mse" mean square error        alt. loss = loss_fn for categoricalCross   
            metrics=['accuracy']
            )
        return model


    def _train_AI(self):
        """
        Retrieves Data, and trains core AI
        """
        self._load_data()
        self.core.fit(self.train_x, self.train_y,batch_size=100, epochs=5)
        self.core.evaluate(self.test_x,  self.test_y, verbose=2)



    def _test(self):
        for n in range(5,10):
            print()
            print(self.test_x[n])
            print()
            print(self.test_y[n])

            trial = self.test_x[n].reshape(-1,28,28,1)
            print()
            #print(trial.shape)
            predictions = self.core(trial)
            print()
            print(predictions.numpy())
            print(tf.nn.softmax(predictions).numpy())
            print()

    def recognize(self,img):
        """
        Run digit recognition on input image:
        <img>: numpy array of shape (1,28,28,1)
        returns <result> tuple of numpy array of digit scores between 0 and 255 and a string comment
        """

        output = self.core.predict(img)
        predictions = np.around(output[0],decimals=0)
        comment = self._banter(output[0])
        return (predictions,comment)



    def _banter(self,arr):
        numbers = []
        level = None

        for n,score in enumerate(arr):
            if score > 190:
                level = "certain"
                numbers.append((n, score))

        if not level:
            for n,score in enumerate(arr):
                if score > 150:
                    level = "confident"
                    numbers.append((n, score))

        if not level:
            for n,score in enumerate(arr):
                if score > 60:
                    level = "unsure"
                    numbers.append((n, score))

        if not level:
            level = "clueless"


        rand = randint(0,2)
        numbers.sort(key=lambda score: score[1], reverse = True)

        # Generate start of the comment
        comm_list = [self.primer[level][rand]]

        # add found numbers
        if numbers:
            for n,number in enumerate(numbers):
                comm_list.append(self.digit[number[0]])
                if n < len(numbers)-2:
                    comm_list.append(", ")
                elif n == len(numbers) - 2:
                    comm_list.append(" or ")
        comm_list.append(".")
        comment = "".join(comm_list)
        return comment


# tf.nn.softmax(predictions)

if __name__ == "__main__":
    AI = DigitAI()
    AI._test()


